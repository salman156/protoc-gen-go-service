// Code generated by protoc-gen-go-service. DO NOT EDIT.
// versions:
// 	protoc-gen-go-service v0.1.0
// 	protoc              (unknown)
// source: helloservice.proto

package hello

import (
	context "context"
	grpc "google.golang.org/grpc"
)

type _SearchServiceImpl struct {
	impl        SearchServiceServer
	interceptor grpc.UnaryServerInterceptor
}

func RegisterSearchServiceImpl(s grpc.ServiceRegistrar, impl SearchServiceServer, interceptor grpc.UnaryServerInterceptor) {
	service := &_SearchServiceImpl{impl: impl, interceptor: interceptor}

	s.RegisterService(&SearchService_ServiceDesc, service)
}

func (s *_SearchServiceImpl) PerformSearch(ctx context.Context, req *SearchRequest) (*SearchResponse, error) {
	if s.interceptor != nil {
		handler := func(ctx context.Context, req any) (any, error) {
			return s.impl.PerformSearch(ctx, req.(*SearchRequest))
		}
		info := &grpc.UnaryServerInfo{
			Server:     s,
			FullMethod: SearchService_PerformSearch_FullMethodName,
		}

		resp, err := s.interceptor(ctx, &req, info, handler)

		return resp.(*SearchResponse), err
	}

	return s.impl.PerformSearch(ctx, req)
}

type _TwoRPCServiceImpl struct {
	impl        TwoRPCServiceServer
	interceptor grpc.UnaryServerInterceptor
}

func RegisterTwoRPCServiceImpl(s grpc.ServiceRegistrar, impl TwoRPCServiceServer, interceptor grpc.UnaryServerInterceptor) {
	service := &_TwoRPCServiceImpl{impl: impl, interceptor: interceptor}

	s.RegisterService(&TwoRPCService_ServiceDesc, service)
}

func (s *_TwoRPCServiceImpl) FirstRPC(ctx context.Context, req *FirstRPCRequest) (*FirstRPCResponse, error) {
	if err := req.ValidateAll(); err != nil {
		return nil, err
	}

	if s.interceptor != nil {
		handler := func(ctx context.Context, req any) (any, error) {
			return s.impl.FirstRPC(ctx, req.(*FirstRPCRequest))
		}
		info := &grpc.UnaryServerInfo{
			Server:     s,
			FullMethod: TwoRPCService_FirstRPC_FullMethodName,
		}

		resp, err := s.interceptor(ctx, &req, info, handler)

		return resp.(*FirstRPCResponse), err
	}

	return s.impl.FirstRPC(ctx, req)
}

func (s *_TwoRPCServiceImpl) SecondRPC(ctx context.Context, req *SecondRPCRequest) (*SecondRPCResponse, error) {
	if s.interceptor != nil {
		handler := func(ctx context.Context, req any) (any, error) {
			return s.impl.SecondRPC(ctx, req.(*SecondRPCRequest))
		}
		info := &grpc.UnaryServerInfo{
			Server:     s,
			FullMethod: TwoRPCService_SecondRPC_FullMethodName,
		}

		resp, err := s.interceptor(ctx, &req, info, handler)

		return resp.(*SecondRPCResponse), err
	}

	return s.impl.SecondRPC(ctx, req)
}

type _StreamingServiceImpl struct {
	impl        StreamingServiceServer
	interceptor grpc.UnaryServerInterceptor
}

func RegisterStreamingServiceImpl(s grpc.ServiceRegistrar, impl StreamingServiceServer, interceptor grpc.UnaryServerInterceptor) {
	service := &_StreamingServiceImpl{impl: impl, interceptor: interceptor}

	s.RegisterService(&StreamingService_ServiceDesc, service)
}

func (s *_StreamingServiceImpl) ClientStreamRPC(stream grpc.ClientStreamingServer[ClientStreamRPCRequest, ClientStreamRPCResponse]) error {
	panic("not implemented")
}
func (s *_StreamingServiceImpl) ServerStreamRPC(req *ServerStreamRPCRequest, stream grpc.ServerStreamingServer[ServerStreamRPCResponse]) error {
	panic("not implemented")
}
func (s *_StreamingServiceImpl) BiStreamRPC(stream grpc.BidiStreamingServer[BiStreamRPCRequest, BiStreamRPCResponse]) error {
	panic("not implemented")
}
